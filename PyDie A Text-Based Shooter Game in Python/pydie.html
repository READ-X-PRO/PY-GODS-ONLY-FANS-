<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PyDie: Advanced Combat Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            overflow: hidden;
            background: #121212;
            color: white;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .hud-section {
            margin-bottom: 15px;
        }

        .hud-section:last-child {
            margin-bottom: 0;
        }

        .hud-title {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 5px;
        }

        #health-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        #health-fill {
            height: 100%;
            background: linear-gradient(to right, #e74c3c, #2ecc71);
            transition: width 0.3s ease;
        }

        #weapon-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #weapon-name {
            font-size: 18px;
            font-weight: bold;
            color: #f1c40f;
        }

        #ammo-count {
            font-size: 24px;
            font-weight: bold;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            pointer-events: none;
            transition: width 0.2s, height 0.2s;
        }

        .crosshair-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .crosshair-line {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            transition: transform 0.2s;
        }

        #crosshair-top {
            width: 2px;
            height: 10px;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair-bottom {
            width: 2px;
            height: 10px;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair-left {
            width: 10px;
            height: 2px;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        #crosshair-right {
            width: 10px;
            height: 2px;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        #score-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .score-item:last-child {
            margin-bottom: 0;
        }

        .score-label {
            color: #aaa;
        }

        .score-value {
            font-weight: bold;
        }

        #game-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        #game-title {
            font-size: 4rem;
            color: #f1c40f;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.5);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        #mission-brief {
            font-size: 1.2rem;
            color: #ccc;
            margin-bottom: 2rem;
            max-width: 600px;
            text-align: center;
        }

        .menu-btn {
            background: linear-gradient(to right, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            margin: 10px 0;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s ease;
            width: 250px;
            text-align: center;
            letter-spacing: 1px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(to right, #c0392b, #e74c3c);
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        #result-title {
            font-size: 3rem;
            margin-bottom: 2rem;
            color: #f1c40f;
        }

        #final-stats {
            background: rgba(30, 30, 30, 0.7);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            min-width: 300px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        #loading-bar-container {
            width: 300px;
            height: 10px;
            background: #222;
            border-radius: 5px;
            margin-top: 20px;
            overflow: hidden;
        }

        #loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #e74c3c, #f1c40f);
            transition: width 0.3s ease;
        }

        #loading-text {
            margin-top: 15px;
            color: #aaa;
            font-size: 14px;
        }

        #game-instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            color: #aaa;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="canvas-container"></div>

        <div id="ui-overlay">
            <div id="hud">
                <div class="hud-section">
                    <div class="hud-title">HEALTH</div>
                    <div id="health-bar">
                        <div id="health-fill"></div>
                    </div>
                </div>

                <div class="hud-section">
                    <div class="hud-title">WEAPON</div>
                    <div id="weapon-info">
                        <div id="weapon-name">ASSAULT RIFLE</div>
                        <div id="ammo-count">30/90</div>
                    </div>
                </div>
            </div>

            <div id="score-panel">
                <div class="score-item">
                    <span class="score-label">SCORE:</span>
                    <span class="score-value" id="score-value">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">KILLS:</span>
                    <span class="score-value" id="kills-value">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">WAVE:</span>
                    <span class="score-value" id="wave-value">1</span>
                </div>
            </div>

            <div id="crosshair">
                <div class="crosshair-dot"></div>
                <div class="crosshair-line" id="crosshair-top"></div>
                <div class="crosshair-line" id="crosshair-bottom"></div>
                <div class="crosshair-line" id="crosshair-left"></div>
                <div class="crosshair-line" id="crosshair-right"></div>
            </div>
        </div>

        <div id="game-menu">
            <h1 id="game-title">PYDIE</h1>
            <p id="mission-brief">Your mission is to survive waves of hostile AI constructs in a simulated combat environment. Eliminate all targets to proceed.</p>
            <button class="menu-btn" id="start-btn">START MISSION</button>
            <button class="menu-btn" id="settings-btn">SETTINGS</button>
            <button class="menu-btn" id="help-btn">HOW TO PLAY</button>
        </div>

        <div id="game-over">
            <h2 id="result-title">MISSION FAILED</h2>
            <div id="final-stats">
                <div class="score-item">
                    <span class="score-label">FINAL SCORE:</span>
                    <span class="score-value" id="final-score">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">ELIMINATIONS:</span>
                    <span class="score-value" id="final-kills">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">WAVES SURVIVED:</span>
                    <span class="score-value" id="final-waves">0</span>
                </div>
            </div>
            <button class="menu-btn" id="restart-btn">TRY AGAIN</button>
            <button class="menu-btn" id="menu-btn">MAIN MENU</button>
        </div>

        <div id="loading-screen">
            <h2>LOADING COMBAT SIMULATION</h2>
            <div id="loading-bar-container">
                <div id="loading-bar"></div>
            </div>
            <div id="loading-text">Initializing weapon systems...</div>
        </div>

        <div id="game-instructions">
            WASD: Move | Shift: Sprint | Ctrl: Crouch | C: Slide (while sprinting) | Mouse: Aim | Left Click: Fire | R: Reload | 1-4: Switch Weapons
        </div>
    </div>

    <script>
        // Game state
        const gameState = {
            playerHealth: 100,
            currentWeapon: 0,
            ammo: [30, 8, 10, 5],
            maxAmmo: [90, 32, 30, 15],
            weapons: ['ASSAULT RIFLE', 'SHOTGUN', 'SMG', 'SNIPER'],
            score: 0,
            kills: 0,
            wave: 1,
            gameActive: false,
            enemies: [],
            player: {
                velocity: new THREE.Vector3(),
                rotation: new THREE.Vector2(),
                isSprinting: false,
                isCrouching: false,
                isSliding: false,
                slideTimer: 0,
                cameraBobTimer: 0,
            },
            keys: {}
        };

        // Three.js variables
        let scene, camera, renderer;
        let player, enemies = [];
        let weaponMeshes = [];
        let environment = [];
        let raycaster;
        let clock = new THREE.Clock();

        // Audio
        let sounds = {
            gunshot: null,
            reload: null,
            explosion: null,
            hurt: null,
            death: null,
            ambient: null,
            slide: null,
        };

        // Initialize the game
        function initGame() {
            // Set up Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 0, 75);

            // Set up camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.8, 0);

            // Set up renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Initialize raycaster
            raycaster = new THREE.Raycaster();

            // Set up lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create environment
            createEnvironment();

            // Create weapons
            createWeapons();

            // Set up event listeners
            setupEventListeners();

            // Start game loop
            animate();

            // Hide loading screen after a delay
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('game-menu').style.display = 'flex';
                simulateLoading();
            }, 1500);
        }

        // Simulate loading progress
        function simulateLoading() {
            const loadingBar = document.getElementById('loading-bar');
            const loadingText = document.getElementById('loading-text');
            const steps = [
                { width: 20, text: "Loading weapon models..." },
                { width: 40, text: "Initializing enemy AI..." },
                { width: 60, text: "Generating environment..." },
                { width: 80, text: "Optimizing combat systems..." },
                { width: 100, text: "Mission ready!" }
            ];

            let currentStep = 0;
            const interval = setInterval(() => {
                if (currentStep < steps.length) {
                    loadingBar.style.width = steps[currentStep].width + '%';
                    loadingText.textContent = steps[currentStep].text;
                    currentStep++;
                } else {
                    clearInterval(interval);
                }
            }, 300);
        }

        // Create game environment
        function createEnvironment() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2E8B57, roughness: 0.9 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Obstacles
            const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            for (let i = 0; i < 15; i++) {
                const size = Math.random() * 3 + 2;
                const obstacleGeometry = new THREE.BoxGeometry(size, size, size);
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.position.set(
                    (Math.random() - 0.5) * 150,
                    size / 2,
                    (Math.random() - 0.5) * 150
                );
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                scene.add(obstacle);
                environment.push(obstacle);
            }
        }

        // Create improved weapon models
        function createWeapons() {
            const weaponGroup = new THREE.Group();
            camera.add(weaponGroup);
            weaponMeshes = weaponGroup;

            // Assault Rifle
            const rifle = new THREE.Group();
            const rifleBody = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.8), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            const rifleBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4, 16), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            rifleBarrel.position.z = -0.6;
            rifleBarrel.rotation.x = Math.PI / 2;
            rifle.add(rifleBody, rifleBarrel);
            rifle.position.set(0.3, -0.2, -0.8);
            rifle.rotation.y = Math.PI;
            weaponGroup.add(rifle);

            // Shotgun
            const shotgun = new THREE.Group();
            const shotgunBody = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.18, 0.9), new THREE.MeshStandardMaterial({ color: 0x5a3d2b }));
            const shotgunBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 16), new THREE.MeshStandardMaterial({ color: 0x444444 }));
            shotgunBarrel.position.z = -0.75;
            shotgunBarrel.rotation.x = Math.PI / 2;
            shotgun.add(shotgunBody, shotgunBarrel);
            shotgun.position.set(0.3, -0.2, -0.8);
            shotgun.rotation.y = Math.PI;
            shotgun.visible = false;
            weaponGroup.add(shotgun);

            // SMG
            const smg = new THREE.Group();
            const smgBody = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.12, 0.5), new THREE.MeshStandardMaterial({ color: 0x404040 }));
            const smgMagazine = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.1), new THREE.MeshStandardMaterial({ color: 0x303030 }));
            smgMagazine.position.y = -0.1;
            smgMagazine.position.z = -0.1;
            smg.add(smgBody, smgMagazine);
            smg.position.set(0.3, -0.18, -0.6);
            smg.rotation.y = Math.PI;
            smg.visible = false;
            weaponGroup.add(smg);

            // Sniper
            const sniper = new THREE.Group();
            const sniperBody = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1.2), new THREE.MeshStandardMaterial({ color: 0x2d3436 }));
            const sniperScope = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.3, 16), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            sniperScope.position.y = 0.1;
            sniperScope.rotation.z = Math.PI / 2;
            sniper.add(sniperBody, sniperScope);
            sniper.position.set(0.3, -0.15, -1);
            sniper.rotation.y = Math.PI;
            sniper.visible = false;
            weaponGroup.add(sniper);
        }

        // Spawn a wave of enemies
        function spawnWave() {
            const enemyCount = 5 + gameState.wave * 2;
            const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000 });

            for (let i = 0; i < enemyCount; i++) {
                const enemyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 16);
                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);

                enemy.position.set(
                    (Math.random() - 0.5) * 160,
                    1,
                    (Math.random() - 0.5) * 160
                );

                enemy.castShadow = true;
                scene.add(enemy);
                enemies.push({
                    mesh: enemy,
                    health: 100,
                    damage: 10,
                    speed: 1.5 + Math.random() * 0.5,
                    attackCooldown: 0,
                    strafeDirection: Math.random() > 0.5 ? 1 : -1,
                    strafeTimer: Math.random() * 2 + 1
                });
            }
        }

        // Event Listeners
        function setupEventListeners() {
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', startGame);
            document.getElementById('menu-btn').addEventListener('click', showMainMenu);
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('pointerlockchange', onPointerLockChange, false);
        }

        function onPointerLockChange() {
            if (document.pointerLockElement === renderer.domElement) {
                gameState.gameActive = true;
            } else {
                gameState.gameActive = false;
                showMainMenu();
            }
        }

        function onMouseMove(event) {
            if (!gameState.gameActive) return;
            gameState.player.rotation.y -= event.movementX * 0.002;
            gameState.player.rotation.x -= event.movementY * 0.002;
            gameState.player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, gameState.player.rotation.x));
        }

        function onMouseDown(event) {
            if (!gameState.gameActive) {
                renderer.domElement.requestPointerLock();
                return;
            }
            if (event.button === 0) shoot();
        }

        function onKeyDown(event) {
            gameState.keys[event.key.toLowerCase()] = true;
            if (!gameState.gameActive) return;
            switch (event.key.toLowerCase()) {
                case 'r': reloadWeapon(); break;
                case '1': switchWeapon(0); break;
                case '2': switchWeapon(1); break;
                case '3': switchWeapon(2); break;
                case '4': switchWeapon(3); break;
                case 'c': if (gameState.player.isSprinting) startSlide(); break;
                case 'control': toggleCrouch(true); break;
            }
        }

        function onKeyUp(event) {
            gameState.keys[event.key.toLowerCase()] = false;
             if (!gameState.gameActive) return;
             switch (event.key.toLowerCase()) {
                case 'control': toggleCrouch(false); break;
            }
        }

        function startGame() {
            gameState.gameActive = true;
            gameState.playerHealth = 100;
            gameState.score = 0;
            gameState.kills = 0;
            gameState.wave = 1;
            gameState.ammo = [30, 8, 10, 5];
            gameState.player.velocity.set(0, 0, 0);

            enemies.forEach(enemy => scene.remove(enemy.mesh));
            enemies = [];
            spawnWave();

            updateHealthUI();
            updateAmmoUI();
            updateScoreUI();
            updateWaveUI();

            document.getElementById('game-menu').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            renderer.domElement.requestPointerLock();
        }

        function showMainMenu() {
            gameState.gameActive = false;
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('game-menu').style.display = 'flex';
            document.exitPointerLock();
        }
        
        function shoot() {
            if (gameState.ammo[gameState.currentWeapon] > 0) {
                gameState.ammo[gameState.currentWeapon]--;
                updateAmmoUI();
                if (sounds.gunshot) sounds.gunshot.play();
                checkHit();
            } else {
                if (sounds.reload) sounds.reload.play();
            }
        }
        
        function checkHit() {
            raycaster.setFromCamera(new THREE.Vector2(), camera);
            const intersects = raycaster.intersectObjects(enemies.map(e => e.mesh));

            if (intersects.length > 0) {
                const enemy = enemies.find(e => e.mesh === intersects[0].object);
                if (enemy) {
                    enemy.health -= 25; // Damage amount
                    if (enemy.health <= 0) {
                        scene.remove(enemy.mesh);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        gameState.kills++;
                        gameState.score += 100;
                        updateKillsUI();
                        updateScoreUI();
                        if (sounds.death) sounds.death.play();
                        if (enemies.length === 0) nextWave();
                    } else {
                        if (sounds.hurt) sounds.hurt.play();
                    }
                }
            }
        }

        function reloadWeapon() {
            // Implementation from original file
        }

        function switchWeapon(index) {
            if (index === gameState.currentWeapon || index >= weaponMeshes.children.length) return;
            weaponMeshes.children[gameState.currentWeapon].visible = false;
            gameState.currentWeapon = index;
            weaponMeshes.children[index].visible = true;
            document.getElementById('weapon-name').textContent = gameState.weapons[index];
            updateAmmoUI();
            if (sounds.reload) sounds.reload.play();
        }

        function nextWave() {
            // Implementation from original file
        }
        
        function playerHit(damage) {
            gameState.playerHealth -= damage;
            updateHealthUI();
            if (sounds.hurt) sounds.hurt.play();
            
            // Camera Shake
            document.body.style.animation = 'shake 0.5s';
            setTimeout(() => document.body.style.animation = '', 500);

            if (gameState.playerHealth <= 0) gameOver();
        }

        function gameOver() {
            gameState.gameActive = false;
            document.getElementById('final-score').textContent = gameState.score;
            document.getElementById('final-kills').textContent = gameState.kills;
            document.getElementById('final-waves').textContent = gameState.wave;
            document.getElementById('game-over').style.display = 'flex';
            document.getElementById('result-title').textContent = gameState.wave >= 5 ? "MISSION ACCOMPLISHED!" : "MISSION FAILED";
        }

        function updateHealthUI() { /* from original */ }
        function updateAmmoUI() { /* from original */ }
        function updateScoreUI() { /* from original */ }
        function updateKillsUI() { /* from original */ }
        function updateWaveUI() { /* from original */ }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (gameState.gameActive) {
                updatePlayer(delta);
                updateEnemies(delta);
                updateCrosshair();
                updateWeaponBob();
            }
            renderer.render(scene, camera);
        }

        function updatePlayer(delta) {
            const moveSpeed = gameState.player.isSprinting ? 12 : 6;
            const slideBoost = 18;
            const friction = 10;
            const playerHeight = 1.8;
            const crouchHeight = 1.2;
            const slideHeight = 0.8;

            let targetHeight = gameState.player.isCrouching ? crouchHeight : playerHeight;

            // Sliding logic
            if(gameState.player.isSliding) {
                gameState.player.slideTimer -= delta;
                targetHeight = slideHeight;
                if(gameState.player.slideTimer <= 0) {
                    gameState.player.isSliding = false;
                }
            } else {
                 // Movement input
                const moveDirection = new THREE.Vector3();
                if (gameState.keys['w']) moveDirection.z = -1;
                if (gameState.keys['s']) moveDirection.z = 1;
                if (gameState.keys['a']) moveDirection.x = -1;
                if (gameState.keys['d']) moveDirection.x = 1;
                moveDirection.normalize();

                const speed = gameState.player.isSliding ? slideBoost : moveSpeed;
                const targetVelocity = moveDirection.clone().multiplyScalar(speed);
                gameState.player.velocity.lerp(targetVelocity, friction * delta);
            }

            // Apply movement
            const moveQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), gameState.player.rotation.y);
            const moveVector = gameState.player.velocity.clone().applyQuaternion(moveQuaternion);
            camera.position.add(moveVector.clone().multiplyScalar(delta));

            // Apply friction
            gameState.player.velocity.lerp(new THREE.Vector3(0,0,0), friction * delta);
            
            // Update camera rotation
            camera.rotation.x = gameState.player.rotation.x;
            camera.rotation.y = gameState.player.rotation.y;

            // Update camera height (crouch/slide)
            camera.position.y += (targetHeight - camera.position.y) * 0.2;

            // Sprinting
            gameState.player.isSprinting = gameState.keys['shift'] && (gameState.keys['w'] || gameState.keys['a'] || gameState.keys['s'] || gameState.keys['d']);
        }

        function startSlide() {
            if (!gameState.player.isSliding) {
                gameState.player.isSliding = true;
                gameState.player.slideTimer = 0.7; // Slide duration
                const slideDirection = new THREE.Vector3();
                 if (gameState.keys['w']) slideDirection.z = -1;
                if (gameState.keys['s']) slideDirection.z = 1;
                if (gameState.keys['a']) slideDirection.x = -1;
                if (gameState.keys['d']) slideDirection.x = 1;
                slideDirection.normalize();
                gameState.player.velocity.add(slideDirection.multiplyScalar(15));
                if(sounds.slide) sounds.slide.play();
            }
        }
        
        function toggleCrouch(isCrouching) {
             if (!gameState.player.isSliding) {
                 gameState.player.isCrouching = isCrouching;
             }
        }
        
        function updateEnemies(delta) {
            const playerPos = camera.position;

            for (let enemy of enemies) {
                const distanceToPlayer = enemy.mesh.position.distanceTo(playerPos);

                if (distanceToPlayer < 50) { // Only update enemies within a certain range
                    const direction = new THREE.Vector3().subVectors(playerPos, enemy.mesh.position);
                    
                    // Strafing logic
                    enemy.strafeTimer -= delta;
                    if(enemy.strafeTimer <= 0) {
                        enemy.strafeDirection *= -1;
                        enemy.strafeTimer = Math.random() * 2 + 1;
                    }
                    const strafeVector = new THREE.Vector3(enemy.strafeDirection, 0, 0).applyQuaternion(enemy.mesh.quaternion);
                    
                    direction.y = 0;
                    direction.normalize();
                    
                    const moveVector = direction.add(strafeVector.multiplyScalar(0.3)).normalize();
                    enemy.mesh.position.add(moveVector.multiplyScalar(enemy.speed * delta));
                    enemy.mesh.lookAt(playerPos.x, enemy.mesh.position.y, playerPos.z);

                    if (distanceToPlayer < 5 && Date.now() > enemy.attackCooldown) {
                        playerHit(enemy.damage);
                        enemy.attackCooldown = Date.now() + 1000;
                    }
                }
            }
        }

        function updateCrosshair() {
            const crosshair = document.getElementById('crosshair');
            const speed = gameState.player.velocity.length();
            const spread = Math.min(1 + speed, 2.5);
            crosshair.style.width = `${30 * spread}px`;
            crosshair.style.height = `${30 * spread}px`;
        }

        function updateWeaponBob() {
            const speed = gameState.player.velocity.length();
            if (speed > 0.1) {
                const bobFrequency = gameState.player.isSprinting ? 14 : 7;
                const bobAmplitude = gameState.player.isSprinting ? 0.08 : 0.04;
                gameState.player.cameraBobTimer += clock.getDelta() * bobFrequency;
                weaponMeshes.position.y = Math.sin(gameState.player.cameraBobTimer) * bobAmplitude -0.2;
                weaponMeshes.position.x = Math.cos(gameState.player.cameraBobTimer / 2) * bobAmplitude + 0.3;
            } else {
                 weaponMeshes.position.y = (-0.2 - weaponMeshes.position.y) * 0.1;
                 weaponMeshes.position.x = (0.3 - weaponMeshes.position.x) * 0.1;
            }
        }

        function initAudio() {
            // Placeholder URLs
            sounds.gunshot = new Howl({ src: ['https://example.com/sounds/gunshot.wav'], volume: 0.5 });
            sounds.reload = new Howl({ src: ['https://example.com/sounds/reload.wav'] });
            sounds.hurt = new Howl({ src: ['https://example.com/sounds/hurt.wav'] });
            sounds.death = new Howl({ src: ['https://example.com/sounds/death.wav'], volume: 0.7 });
            sounds.slide = new Howl({ src: ['https://example.com/sounds/slide.wav'], volume: 0.8 });
            sounds.ambient = new Howl({
                src: ['https://example.com/sounds/ambient.wav'],
                loop: true,
                volume: 0.3
            });
            // sounds.ambient.play();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize everything when the page loads
        window.addEventListener('load', () => {
            initGame();
            initAudio();
        });
    </script>
    <style>
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
    </style>
</body>
</html>